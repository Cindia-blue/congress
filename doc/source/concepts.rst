.. include:: aliases.rst

.. _concepts:


### We should remove this section and just have the Policy and Services sections.

==============
Basic Concepts
==============


A **service** is anything that manages cloud state.  For example, OpenStack
components like Nova, Neutron, Cinder, Swift, Heat, and Keystone are all
services.  Software like |ad|, inventory management systems, anti-virus
scanners, intrusion detection systems, and relational databases are also
services.

The **state** of the cloud is a snapshot at any point in time of all
information stored within the cloud's services.  For Neutron, the existing
logical networks, subnets, and ports make up that state.  For
Nova, the existing VMs along with their disk and memory space make up that
state.  For an anti-virus scanner, the results of all its most recent
scans are the state.

Once the cloud operator gives Congress a policy (a description of the permitted states of the
cloud), Congress will monitor the actual state of the cloud, compare
it to policy, and warn the cloud operator about policy violations (when the cloud's actual
state is one that a policy does not permit).  In the future, Congress will
go farther and take action to change the state of the cloud (enforcement) and
help us understand the history of policy and its violations (auditing).

Interacting with Congress
---------------------

Congress runs as a standalone cloud service; and a client executes a
command by sending an HTTP request to the congress server.  The API
allows clients to create policies, read policies, read input data
sources, and read state tables (including policy violation tables).
Instructions for starting the Congress web server can be found in the
:ref:`Readme <readme>` file.  The format for HTTP requests can be
found later in this documentation.


Plug-n-Play Architecture for Cloud Services
--------------------------------------------

The key design goal of Congress is that it should work with ANY collection of
cloud services.  It should be straightforward to add a new service and
immediately start writing policy over that service.  In other words, Congress
has a plug-n-play architecture for services.

The only requirement Congress imposes on a cloud service is that it must be
possible to represent the state of the service as a collection of tables.
A table is something we are all familar with from HTML, Excel, and relational
databases.  A **table** is a collection of rows, where each row is a
collection of columns, and a simple data element (e.g. string, number) is
stored in each row-column entry.

To plug a new service into Congress, we need to write a small piece of code
(a *driver*) that executes API calls on the new service and translates them
into tables of data.  Then we tell Congress where to find that driver, how to
configure it (e.g. with IP address/port/username), and what name we'll use in
policy to refer to the tables generated by that driver.

For example, the driver for Neutron invokes the Neutron API calls that list
networks, ports, security groups, and routers.  The driver translates each of
the JSON objects that the API calls returns into tables (which in Python we
represent as a list of tuples).  The Neutron driver is::

    congress/congress/datasources/neutron_driver.py

Out of the box this driver is given the name 'neutron'.  When writing policy,
we use the name 'neutron:ports' to reference the 'ports' table generated by
the Neutron driver, and we use 'neutron:networks' to reference the 'networks'
table.

------------------
Policy Language
------------------

The main reason to use the table-based plug-n-play architecture described
above instead of something else is that the vast majority of policy languages
developed over the past 50 years have used tables as the main (and often only)
data structure.  Moreover, there's one policy language that stands out as
having proven its ability to scale while providing enough expressiveness for
real-world applications: Datalog.  Datalog, the policy-language of Congress,
is table-based and is similar in many ways to SQL, Datalog, Prolog, and
first-order logic.  While we could have designed a novel language and in so
doing supported a richer data-model than tables, choosing Datalog and the
table-based data model allows us to leverage 50 years of research and
development into implementations known to work at scale.

Conceptually, Datalog is a language for (i) describing invariants that
tables should always obey and (ii) defining new tables from existing tables.
The policy that describes how the cloud should behave is a collection of
Datalog invariants dictating which combinations of tables are permitted and
which are prohibited.  For example, we might want every VM connected to a
network to be a member of the "secure" security group.  This invariant
describes which states of the cloud are permitted.

When writing invariants, it is often useful to use higher-level concepts
than the cloud services provide natively.  Datalog's allows us to do this
by defining new tables (higher-level concepts) in terms of existing tables
(lower-level concepts).  For example, OpenStack does not tell us directly
which VMs are connected to the internet; rather, it provides a collection
of lower-level API calls from which we can derive that information.  Using
Datalog we can define a table that lists all of the VMs connected to the
internet in terms of the tables that Nova/Neutron support directly.

For more information and concrete examples of Datalog, see :ref:`policy`.


------------------
API
------------------

To use Congress, you'll carry out two primary activies.

* Modify policy: change the current contents of policy
* Query policy: ask for the current state of the cloud, the current policy
  violations, the contents of tables, the causes of violations


Congress supports a RESTful API and python client for carrying out these tasks.
Details can be found in :ref:`api`.




