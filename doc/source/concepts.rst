.. include:: aliases.rst

.. _concepts:


=================
Basic Concepts
=================

From Congress's point of view, the cloud is a collection of autonomous
services that are constantly changing the state of the cloud.  Its job is to
help people manage that plethora of changes via policy.

A **policy** describes how services (either individually or as a whole) ought
to behave.  More specifically, a policy describes which **states** of the
cloud are permitted and which are not.  For example, a policy might require
all systems to enforce a minimum password length of 8 characters.

A **service** is anything in the cloud with an API.  For example, OpenStack
components like Nova, Neutron, Cinder, Swift, Heat, and Keystone are all
services.  Software like |ad|, inventory management systems, anti-virus
scanners, intrusion detection systems, and relational databases are also
services.

The **state** of the cloud is a snapshot at any point in time of all
information stored within the cloud's services.  For Neutron, the existing
logical networks, subnets, and ports would be included in the state.  For
Nova, the existing VMs along with their disk and memory space would be included
in state.  For an anti-virus scanner, the results of all its most recent
scans are part of state.


Once we give Congress a policy (a description of the permitted states of the
cloud), Congress will help us monitor the actual state of the cloud, compare
it to policy, and warn us about policy violations (when the cloud's actual
state is one that is not permitted by policy).  In the future, Congress will
go farther and take action to change the state of the cloud (enforcement) and
help us understand the history of policy and its violations (auditing).

--------------------------------------------
Plug-n-Play Architecture for Cloud Services
--------------------------------------------

The key design goal of Congress is that it should work with ANY collection of
cloud services.  It should be straightforward to add a new service and
immediately start writing policy over that service.  In other words, Congress
has a plug-n-play architecture for services.

The only requirement Congress imposes on a cloud service is that it must be
possible to represent the state of the service as a collection of tables.
A table is something we are all familar with from HTML, Excel, and relational
databases.  A **table** is a collection of rows, where each row is a
collection of columns, and a simple data element (e.g. string, number) is
stored in each row-column entry.

To plug a new service into Congress, we need to write a small piece of code
(a *driver*) that executes API calls on the new service and translates them
into tables of data.  Then we tell Congress where to find that driver, how to
configure it (e.g. with IP address/port/username), and what name we'll use in
policy to refer to the tables generated by that driver.

For example, the driver for Neutron invokes the Neutron API calls that list
networks, ports, security groups, and routers.  The driver translates each of
the JSON objects that the API calls returns into tables (which in Python we
represent as a list of tuples).  The Neutron driver is::

    congress/congress/datasources/neutron_driver.py

Out of the box this driver is given the name 'neutron'.  When writing policy,
we use the name 'neutron:ports' to reference the 'ports' table generated by
the Neutron driver, and we use 'neutron:networks' to reference the 'networks'
table.

------------------
Policy Language
------------------

The main reason to use the table-based plug-n-play architecture described
above instead of something else is that the vast majority of policy languages
developed over the past 50 years have used tables as the main (and often only)
data structure.  Moreover, there's one policy language that stands out as
having proven its ability to scale while providing enough expressiveness for
real-world applications: Datalog.  Datalog, the policy-language of Congress,
is table-based and is similar in many ways to SQL, Datalog, Prolog, and
first-order logic.  While we could have designed a novel language and in so
doing supported a richer data-model than tables, choosing Datalog and the
table-based data model allows us to leverage 50 years of research and
development into implementations known to work at scale.

Conceptually, Datalog is a language for (i) describing invariants that
tables should always obey and (ii) defining new tables from existing tables.
The policy that describes how the cloud should behave is a collection of
Datalog invariants dictating which combinations of tables are permitted and
which are prohibited.  For example, we might want every VM connected to a
network to be a member of the "secure" security group.  This invariant
describes which states of the cloud are permitted.

When writing invariants, it is often useful to use higher-level concepts
than the cloud services provide natively.  Datalog's allows us to do this
by defining new tables (higher-level concepts) in terms of existing tables
(lower-level concepts).  For example, OpenStack does not tell us directly
which VMs are connected to the internet; rather, it provides a collection
of lower-level API calls from which we can derive that information.  Using
Datalog we can define a table that lists all of the VMs connected to the
internet in terms of the tables that Nova/Neutron support directly.

For more information and concrete examples of Datalog, see :ref:`policy`.


------------------
API
------------------

To use Congress, you'll carry out two primary activies.

* Modify policy: change the current contents of policy
* Query policy: ask for the current state of the cloud, the current policy
  violations, the contents of tables, the causes of violations


Congress supports a RESTful API and python client for carrying out these tasks.
Details can be found in :ref:`api`.




